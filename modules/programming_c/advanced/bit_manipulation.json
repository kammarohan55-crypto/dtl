{
    "module_header": {
        "module_title": "Bit Manipulation",
        "subject": "Programming Using C",
        "level": "Advanced",
        "prerequisites": [
            "Binary number system",
            "Operators in C",
            "Data types and memory representation",
            "Bitwise operators basics"
        ],
        "learning_outcomes": [
            "Understand bitwise operators: AND (&), OR (|), XOR (^), NOT (~), left shift (<<), right shift (>>)",
            "Set, clear, toggle, and check individual bits",
            "Use bit fields in structures for memory-efficient storage",
            "Apply bit masks for flags and permissions",
            "Perform arithmetic and logical operations using bit manipulation",
            "Optimize code using bitwise operations",
            "Understand endianness and byte-level bit manipulation"
        ]
    },
    "definition": "Bit manipulation operates on individual bits using bitwise operators. Operators: AND (&) performs bitwise AND, OR (|) bitwise OR, XOR (^) bitwise exclusive-OR, NOT (~) bitwise complement, left shift (<<) shifts bits left, right shift (>>) shifts bits right. Set bit: `n |= (1 << pos)`, clear bit: `n &= ~(1 << pos)`, toggle bit: `n ^= (1 << pos)`, check bit: `(n & (1 << pos)) != 0`. Bit fields in structures: `struct { unsigned int flag:1; unsigned int value:7; };` pack data efficiently. Applications: flags/permissions, low-level hardware access, optimization, cryptography, compression.",
    "concept_overview": [
        "Bitwise AND (&): 1&1=1, others=0. Use: masking (extract bits), check if bit set.",
        "Bitwise OR (|): 0|0=0, others=1. Use: set bits, combine flags.",
        "Bitwise XOR (^): same=0, different=1. Use: toggle bits, swap without temp, find odd-one-out.",
        "Bitwise NOT (~): flips all bits. ~0=all 1s, ~1=all 1s except LSB.",
        "Left shift (<<): Shifts bits left, fills right with 0. n<<k multiplies by 2^k.",
        "Right shift (>>): Shifts bits right. Logical (fills left with 0) or arithmetic (fills with sign bit).",
        "Set bit: `n |= (1<<pos)`. Clear bit: `n &= ~(1<<pos)`. Toggle: `n ^= (1<<pos)`. Check: `n & (1<<pos)`."
    ],
    "theory": [
        "Bit manipulation provides low-level control over binary representation, enabling efficient operations impossible at higher abstraction levels. Understanding requires binary number representation: each bit position represents power of 2 (LSB=2^0, next=2^1, etc.). Bitwise operators operate on corresponding bit positions independently. AND masks bits (isolates specific bits), OR combines (sets bits), XOR toggles (or finds differences), NOT inverts. Shifts move bits left/right: left shift multiplies by powers of 2, right shift divides. These enable: (1) Space optimization—packing multiple boolean flags in single integer (bit fields). (2) Performance—bitwise operations faster than arithmetic for certain tasks (multiplying/dividing by 2^k). (3) Hardware interface—controlling hardware registers bit-by-bit. (4) Algorithms—bit manipulation tricks for finding powers of 2, counting bits, swapping values. Mastery develops low-level thinking essential for systems programming, embedded development, and algorithmic optimization.",
        "The fundamental bit manipulation techniques involve setting, clearing, toggling, and checking bits using masks and operators. Bit masking: AND with mask extracts specific bits: `value & 0x0F` gets low 4 bits (mask=00001111), `(value >> 4) & 0x0F` gets high 4 bits of byte. Setting bit at position: `number |= (1 << position)` creates mask with bit position set (1<<3 = 00001000), ORs with number to set that bit. Clearing bit: `number &= ~(1 << position)` creates mask with all bits 1 except position, ANDs to clear. Toggling: `number ^= (1 << position)` XORs to flip bit. Checking: `if (number & (1 << position))` tests if bit set. Common tricks: Check if power of 2: `(n & (n-1)) == 0` (power of 2 has single bit set). Count set bits (popcount): loop checking each bit or Brian Kernighan's algorithm `while(n) { count++; n &= (n-1); }` clears rightmost set bit each iteration. Swap without temp: `a ^= b; b ^= a; a ^= b;` XOR swap (same variable swapped becomes 0). Find odd-one-out: `result = x1 ^ x2 ^ x3...` XOR all values, duplicates cancel leaving unique. Bit fields pack data: `struct Flags { unsigned active:1; unsigned mode:2; unsigned priority:3; };` fits in single byte vs 3 bytes for 3 ints. Endianness matters: little-endian stores LSB first, big-endian MSB first—affects byte-level bit manipulation across architectures.",
        "Mastery of bit manipulation is critically important for systems programming, embedded systems, performance optimization, and algorithmic problem-solving. Embedded systems use bit manipulation extensively: control registers where each bit enables/disables feature, status registers indicating device state, GPIO pins controlled bit-by-bit. Operating systems use bits for permissions (read/write/execute flags), process states, memory page attributes. Networking: protocol headers with bit-level fields (TCP flags, IP header fields). Cryptography: bitwise operations in encryption algorithms (XOR for one-time pad, shifts in hashing). Compression: Huffman coding operates on bit streams. Graphics: pixel manipulation, alpha blending using bit operations. Performance: multiply/divide by powers of 2 using shifts faster than arithmetic (compiler often optimizes automatically). Space optimization: packing boolean flags as bits instead of bytes saves memory—important in memory-constrained systems. Common patterns: (1) Flags/options—`#define FLAG_A (1<<0)`, `#define FLAG_B (1<<1)`, enable: `flags |= FLAG_A`, disable: `flags &= ~FLAG_A`, check: `flags & FLAG_A`. (2) Bitmasks for permissions (Unix file permissions: rwxrwxrwx as 9 bits). (3) Fast modulo for power-of-2: `n % 8` equals `n & 7` (faster). (4) Rounding up to power of 2 for alignment. Security: timing attacks on bit operations (constant-time code crucial in crypto). Portability: signed right shift behavior implementation-defined (arithmetic vs logical); use unsigned for portability. In examinations, demonstrating bit set/clear/toggle/check, understanding masks, and applying tricks like power-of-2 check shows low-level programming competence."
    ],
    "mathematical_formulation": [
        {
            "formula": "Set bit: `n |= (1 << pos)` Example: set bit 3: `n |= (1 << 3)` = `n |= 8`",
            "explanation": "Creates mask with bit pos set, ORs to set that bit in n."
        },
        {
            "formula": "Clear bit: `n &= ~(1 << pos)` Example: clear bit 3: `n &= ~(1 << 3)`",
            "explanation": "Creates mask with all 1s except bit pos, ANDs to clear."
        },
        {
            "formula": "Toggle bit: `n ^= (1 << pos)` Example: toggle bit 3: `n ^= (1 << 3)`",
            "explanation": "XORs with mask to flip bit (0→1, 1→0)."
        },
        {
            "formula": "Check bit: `(n & (1 << pos)) != 0` Example: check bit 3: `(n & 8) != 0`",
            "explanation": "ANDs with mask; non-zero means bit is set."
        },
        {
            "formula": "Left shift: `n << k` multiplies by $2^k$. Right shift: `n >> k` divides by $2^k$ (unsigned)",
            "explanation": "Shift operations move bits, equivalent to multiply/divide by powers of 2."
        }
    ],
    "worked_examples": [
        {
            "difficulty": "Basic",
            "problem": "Set, clear, toggle, and check bits.",
            "solution_steps": [
                "```c",
                "#include <stdio.h>",
                "",
                "void printBinary(unsigned char n) {",
                "    for (int i = 7; i >= 0; i--) {",
                "        printf(\"%d\", (n >> i) & 1);",
                "    }",
                "    printf(\"\\n\");",
                "}",
                "",
                "int main() {",
                "    unsigned char n = 0;  // 00000000",
                "    printf(\"Initial: \"); printBinary(n);",
                "    ",
                "    // Set bit 3",
                "    n |= (1 << 3);  // n = 00001000 = 8",
                "    printf(\"After set bit 3: \"); printBinary(n);",
                "    ",
                "    // Set bit 5",
                "    n |= (1 << 5);  // n = 00101000 = 40",
                "    printf(\"After set bit 5: \"); printBinary(n);",
                "    ",
                "    // Clear bit 3",
                "    n &= ~(1 << 3);  // n = 00100000 = 32",
                "    printf(\"After clear bit 3: \"); printBinary(n);",
                "    ",
                "    // Toggle bit 5",
                "    n ^= (1 << 5);  // n = 00000000 = 0",
                "    printf(\"After toggle bit 5: \"); printBinary(n);",
                "    ",
                "    return 0;",
                "}",
                "```"
            ],
            "final_answer": "Use |= to set, &=~ to clear, ^= to toggle bits using masks (1<<pos)."
        },
        {
            "difficulty": "Intermediate",
            "problem": "Check if number is power of 2.",
            "solution_steps": [
                "```c",
                "#include <stdio.h>",
                "#include <stdbool.h>",
                "",
                "bool isPowerOfTwo(int n) {",
                "    // Power of 2 has exactly one bit set",
                "    // n & (n-1) clears rightmost set bit",
                "    // If only one bit set, result is 0",
                "    return (n > 0) && ((n & (n-1)) == 0);",
                "}",
                "",
                "int main() {",
                "    int numbers[] = {1, 2, 3, 4, 5, 8, 16, 15, 32};",
                "    ",
                "    for (int i = 0; i < 9; i++) {",
                "        printf(\"%d is %sa power of 2\\n\", ",
                "               numbers[i],",
                "               isPowerOfTwo(numbers[i]) ? \"\" : \"not \");",
                "    }",
                "    ",
                "    return 0;",
                "}",
                "```",
                "**Explanation:** Power of 2 has one bit: 8=1000. 8-1=7=0111. 8&7=0. Non-power: 6=110, 5=101, 6&5=100≠0."
            ],
            "final_answer": "Power of 2 has single bit set. n & (n-1) == 0 tests this (clears rightmost bit)."
        }
    ],
    "logical_derivation": "Bit representation: integers stored as binary bits, each position=power of 2. Bitwise operators perform Boolean logic on corresponding bit pairs. AND for masking (isolate bits): result has 1 only where both inputs have 1. OR for combining: result has 1 if either input has 1 (sets bits). XOR for toggling/differencing: result has 1 where inputs differ. NOT inverts all bits. Shifts multiply/divide by 2 because binary is base-2 positional: left shift adds 0 on right (multiply by 2), right shift discards rightmost bit (divide by 2). These primitive operations enable complex manipulations: setting/clearing/checking individual bits for flags, packing multiple values in few bytes for space efficiency.",
    "applications": [
        "**Flags/permissions**: Unix permissions (rwx = 3 bits), file attributes, option flags.",
        "**Hardware control**: Setting/clearing control register bits in embedded systems, GPIO pins.",
        "**Optimization**: Fast multiply/divide by powers of 2 using shifts, modulo using AND.",
        "**Cryptography**: XOR encryption, bit permutations in DES/AES.",
        "**Compression**: Bit-level packing in Huffman coding, run-length encoding.",
        "**Graphics**: Pixel manipulation, alpha blending, color extraction.",
        "**Networking**: Protocol header bit fields (TCP flags, IP headers)."
    ],
    "key_takeaways": [
        "Bitwise operators: & (AND), | (OR), ^ (XOR), ~ (NOT), << (left shift), >> (right shift).",
        "Set bit: `n |= (1<<pos)`. Clear: `n &= ~(1<<pos)`. Toggle: `n ^= (1<<pos)`. Check: `n & (1<<pos)`.",
        "Left shift <<: Multiplies by 2^k. Right shift >>: Divides by 2^k  (unsigned).",
        "Power of 2 check: `(n & (n-1)) == 0` (single bit set).",
        "Bit masks: Extract/set specific bits. `value & 0xFF` gets low byte.",
        "Bit fields: Pack multiple values in structure: `struct { unsigned flag:1; unsigned val:7; };`",
        "XOR properties: a^a=0, a^0=a, a^b^b=a. Useful for swap and finding unique element."
    ],
    "common_mistakes": [
        {
            "mistake": "Confusing bitwise & with logical &&",
            "why_it_occurs": "Students use & for boolean logic instead of &&.",
            "how_to_avoid": "Bitwise &: bit-by-bit AND. Logical &&: boolean AND (short-circuits). Use && for if conditions, & for bit operations."
        },
        {
            "mistake": "Not using parentheses with shifts in expressions",
            "why_it_occurs": "Students write `1 << n + 1` expecting `1 << (n+1)`.",
            "how_to_avoid": "Operator precedence: + before <<. `1 << n + 1` is `(1 << n) + 1`. Use parentheses: `1 << (n + 1)`."
        },
        {
            "mistake": "Shifting by negative or >= bit width",
            "why_it_occurs": "Students shift by n where n<0 or n>=sizeof(type)*8.",
            "how_to_avoid": "Shifting int by 32+ bits is undefined behavior. Always validate shift amount: `0 <= shift < (sizeof(type)*8)`."
        },
        {
            "mistake": "Using signed ints for bit manipulation",
            "why_it_occurs": "Students use int instead of unsigned, causing sign extension issues.",
            "how_to_avoid": "Right shift int may arithmetic shift (fills with sign bit). Use unsigned for predictable logical shift."
        },
        {
            "mistake": "Not understanding bit mask creation",
            "why_it_occurs": "StudentsForgot that (1<<pos) creates mask with single bit set.",
            "how_to_avoid": "1<<0=1 (bit 0), 1<<1=2 (bit 1), 1<<3=8 (bit 3). Memorize powers of 2."
        },
        {
            "mistake": "Forgetting ~ creates all bits flipped",
            "why_it_occurs": "Students think ~1 is 0.",
            "how_to_avoid": "~1 is all 1s except LSB (like 0xFFFFFFFE). To clear bit, use: `n &= ~(1<<pos)`."
        }
    ],
    "quiz": [
        {
            "question": "What does bitwise AND (&) do?",
            "options": [
                "Bit-by-bit AND: result bit is 1 only if both input bits are 1",
                "Logical AND",
                "Adds numbers",
                "Checks equality"
            ],
            "correct_answer": 0,
            "explanation": "Bitwise & performs AND on corresponding bits. 1&1=1, others=0. Example: 5&3 = 0101&0011 = 0001 = 1."
        },
        {
            "question": "How to set bit at position 3?",
            "options": [
                "`n |= (1 << 3)`",
                "`n &= (1 << 3)`",
                "`n = 1 << 3`",
                "`n += 3`"
            ],
            "correct_answer": 0,
            "explanation": "(1<<3) creates mask 00001000. OR with n sets bit 3 without affecting others."
        },
        {
            "question": "How to clear bit at position 5?",
            "options": [
                "`n &= ~(1 << 5)`",
                "`n |= ~(1 << 5)`",
                "`n ^= (1 << 5)`",
                "`n -= (1 << 5)`"
            ],
            "correct_answer": 0,
            "explanation": "~(1<<5) creates mask with all 1s except bit 5. AND clears that bit."
        },
        {
            "question": "What does `n << 2` do?",
            "options": [
                "Shifts bits left 2 positions, multiplies by 4",
                "Shifts bits right 2 positions",
                "Adds 2 to n",
                "Rotates bits"
            ],
            "correct_answer": 0,
            "explanation": "Left shift by k multiplies by 2^k. n<<2 multiplies by 4. Example: 5<<2 = 0101<<2 = 10100 = 20."
        },
        {
            "question": "What does XOR (^) do when both bits are same?",
            "options": [
                "Returns 0",
                "Returns 1",
                "Syntax error",
                "Depends on value"
            ],
            "correct_answer": 0,
            "explanation": "XOR: same bits=0, different=1. 0^0=0, 1^1=0, 0^1=1, 1^0=1."
        },
        {
            "question": "How to check if bit 4 is set?",
            "options": [
                "`(n & (1 << 4)) != 0`",
                "`n >> 4`",
                "`n == (1 << 4)`",
                "`n % 4`"
            ],
            "correct_answer": 0,
            "explanation": "AND with mask (1<<4). If bit 4 set, result non-zero. If clear, result 0."
        },
        {
            "question": "What's the value of `~0`?",
            "options": [
                "All bits set to 1",
                "0",
                "1",
                "-1"
            ],
            "correct_answer": 0,
            "explanation": "NOT inverts all bits. ~0 flips all 0s to 1s = 0xFFFFFFFF (on 32-bit). As signed int, this is -1."
        },
        {
            "question": "How to toggle bit 2?",
            "options": [
                "`n ^= (1 << 2)`",
                "`n &= (1 << 2)`",
                "`n |= (1 << 2)`",
                "`n ~= (1 << 2)`"
            ],
            "correct_answer": 0,
            "explanation": "XOR with mask flips bit. If bit was 0→1, if 1→0. n^=(1<<2) toggles bit 2."
        },
        {
            "question": "What does `n & (n-1)` do?",
            "options": [
                "Clears rightmost set bit",
                "Sets rightmost bit",
                "Doubles n",
                "Checks if even"
            ],
            "correct_answer": 0,
            "explanation": "n-1 flips rightmost 1 and all bits to its right. n&(n-1) clears rightmost set bit. Example: 12&11 = 1100&1011 = 1000."
        },
        {
            "question": "How to check if number is power of 2?",
            "options": [
                "`(n > 0) && ((n & (n-1)) == 0)`",
                "`n % 2 == 0`",
                "`n ^ 2 == 0`",
                "`log2(n) == int`"
            ],
            "correct_answer": 0,
            "explanation": "Power of 2 has exactly one bit set. n&(n-1)==0 tests this. 8=1000, 7=0111, 8&7=0. Also check n>0."
        },
        {
            "question": "What does `n >> 1` do for unsigned n?",
            "options": [
                "Divides by 2 (logical shift right)",
                "Multiplies by 2",
                "Adds 1",
                "Subtracts 1"
            ],
            "correct_answer": 0,
            "explanation": "Right shift by 1 divides by 2. n>>1 shifts bits right, discards rightmost bit. 10>>1 = 1010>>1 = 0101 = 5."
        },
        {
            "question": "Difference between & and &&?",
            "options": [
                "& is bitwise AND, && is logical AND",
                "No difference",
                "& for ints, && for bools",
                "& is faster"
            ],
            "correct_answer": 0,
            "explanation": "Bitwise &: AND on each bit. Logical &&: boolean AND (short-circuits, returns 0 or 1). Use && for conditions, & for bit operations."
        }
    ],
    "ai_summary": {
        "key_ideas": [
            "Bitwise operators: & (AND), | (OR), ^ (XOR), ~ (NOT), << (left shift), >> (right shift).",
            "Set bit: `n |= (1<<pos)`. Clear bit: `n &= ~(1<<pos)`. Toggle: `n ^= (1<<pos)`. Check: `(n & (1<<pos)) != 0`.",
            "Left shift <<k multiplies by 2^k. Right shift >>k divides by 2^k (unsigned, logical shift).",
            "Bit mask: (1<<pos) creates mask with bit pos set. ~(1<<pos) has all bits 1 except pos.",
            "Power of 2 check: `(n & (n-1)) == 0` (power of 2 has single bit set).",
            "XOR properties: a^a=0, a^0=a. Useful for toggling, swap without temp, find unique element.",
            "AND for masking (extract bits): `n & 0xFF` gets low byte. OR for setting: `n | mask` sets bits in mask.",
            "Shifts: n<<1 multiplies by 2, n>>1 divides by 2. Efficient for powers of 2.",
            "Use unsigned for bit manipulation—predictable logical right shift, no sign extension.",
            "Common tricks: Check even: `n&1==0`. Count set bits: loop or `n&(n-1)` technique."
        ],
        "important_formulas": [
            "Set: `n |= (1<<pos)`",
            "Clear: `n &= ~(1<<pos)`",
            "Toggle: `n ^= (1<<pos)`",
            "Check: `(n & (1<<pos)) != 0`",
            "Power of 2: `(n & (n-1)) == 0`"
        ],
        "common_exam_traps": [
            "Confusing & (bitwise) with && (logical)—use && for if conditions, & for bit ops.",
            "Missing parentheses: `1 << n + 1` is `(1<<n)+1` not `1<<(n+1)`. Add parentheses.",
            "Using signed ints—right shift may arithmetic shift (sign ext). Use unsigned for predictable shift.",
            "Forgetting ~1 is all 1s except LSB, not 0. To clear bit: `n &= ~(1<<pos)`.",
            "Shift by >=width undefined: shifting 32-bit int by 32+ is UB. Validate shift amount."
        ],
        "exam_tip": "Remember: Set with OR, clear with AND NOT, toggle with XOR, check with AND. Powers of 2: single bit set, test with n&(n-1)==0. Shifts multiply/divide by 2^k. Use unsigned for bitwise ops."
    }
}